<!doctype html>
<html>
<head>
<title>Mmvp Demo</title>

<script type='text/javascript' src='../underscore.min.js'></script>
<script type='text/javascript' src='../mmvp.js'></script>

<script type='text/javascript' src='js/lib/zepto.js'></script>
<script type='text/javascript' src='js/lib/shCore.js'></script>
<script type='text/javascript' src='js/lib/shBrushJScript.js'></script>
<script type='text/javascript' src='js/presenter-example-code.js'></script>

<link rel='stylesheet' href='css/style.css' />
<link rel='stylesheet' href='css/shCoreDefault.css' />
</head>

<body>
<main>
  <h1>Mmvp.js</h1>
  <span class='subline'>(&micro;) model view presenter library</span>

<section id="overview">
  <div class='sidebar'>
    <h2>Abstract</h2>
  </div>
  <p><a href="#">Front</a>-<a href="#">end</a> <a href="#">frameworks</a>, in process of providing model-to-view binding architecture, bundle along things like DOM buttresses, templating engines, and UI widgets. In effect, <i>how</i> you build application's UI, presenters, and animation logic is (de)fined.</p>
  <p><a href="http://github.com/mil/mmvp.js">Mmvp.js</a> takes an alternative approach. Aiming for presenter malleability, you bind <code>empty</code>, <code>populate</code>, <code>add</code>, <code>remove</code>, and <code>update</code> callbacks to perform templating, DOM manipulation, and your other presentation logic for when changes in your model occur. Periodically re-<code>sync</code> the presenter, and that's pretty much it.</p>
</section>
<section id="demo">
  <div class='sidebar'>
    <h2>Demo</h2>
  </div>
    <nav>
      <div class='app'>
        <h2 class='view active'>View</h2>
        <h2 class='model'>Model</h2>
      </div><div class='src'>
        <h2 class='implementation'>Todo.js</h2>
        <h2 class='source'>Mmvp.js</h2>
      </div>
    </nav>



  <section id='switcher'> 
    <section class='view active'>  
      <div id="viewpen"></div>
      <div id='buttons'>
        <input type='text' placeholder='Type Here'>
      </div>
    </section>
    <section class='model'>
      MY MODEL
    </section>
    <section class='source'>
      <a href="">plain</a>
      <pre class='brush: js;'>
var Mmvp = (function(my) {
  var actions = {
    add      : function() {},
    remove   : function() {},
    update   : function() {},
    populate : function() {},
    empty    : function() {}
  }, 
  model = {};

  function sync(hash_with_unique_keys) { 
    var add_items = _.omit(hash_with_unique_keys, _.keys(model));
    var remove_items = _.omit(model, _.keys(hash_with_unique_keys));

    _.each(_.pick(model, _.keys(hash_with_unique_keys)), function(v,k) {
      _.each(_.keys(model[k]), function(key) {
        if (model[k][key] != hash_with_unique_keys[k][key]) {
          model[k] = hash_with_unique_keys[k];
          actions['update'](k,model[k]);
          return;
        }
      });
    });

    if (_.size(hash_with_unique_keys) == 0 && _.size(model) != 0) { actions['empty'](); }
    if (_.size(model) == 0 && _.size(hash_with_unique_keys) != 0) { actions['populate'](); }

    _.each(add_items, function(value, key) { actions['add'](key, value); });
    _.each(remove_items, function(value, key) { actions['remove'](key, value) });

    model = _.clone(hash_with_unique_keys);
    return true;
  }
  return {
    initialize : function() { actions.empty(); },
    set_action : function(new_hash) {
      if (actions['add']) { actions.add = new_hash.add; }
      if (actions['remove']) { actions.remove = new_hash.remove; }
      if (actions['populate']) { actions.populate = new_hash.populate; }
      if (actions['empty']) { actions.empty = new_hash.empty; }
    },
    sync : sync
  };
});
      </pre>
    </section>
    <section class='implementation'>
      IMPLEMENTATUION
    </section>
  </section>

</section>

</body>
</html>

